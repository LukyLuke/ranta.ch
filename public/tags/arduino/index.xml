<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arduino on RANTA - Coding, Hacking, Teaching and more</title>
    <link>//ranta.ch/tags/arduino/index.xml</link>
    <description>Recent content in Arduino on RANTA - Coding, Hacking, Teaching and more</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-ch</language>
    <atom:link href="//ranta.ch/tags/arduino/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ESP-32/ESP-WROOM-32 verkabeln und programmieren</title>
      <link>//ranta.ch/tutorials/ESP-32-Initial/</link>
      <pubDate>Thu, 17 Aug 2017 18:45:59 +0200</pubDate>
      
      <guid>//ranta.ch/tutorials/ESP-32-Initial/</guid>
      <description>

&lt;p&gt;Die ESP-32 Mikrokontroller Familie sind ein optimales Produkt für IoT Sachen. Hergestellt werden sie von Espressif Systems und sind ein sogenanntes Low-Power System on a Chip (SoC) mit integriertem WiFi und dual-mode Bluetooth funktionalität. Mehr dazu auf der Webseite &lt;a href=&#34;http://esp32.net/&#34;&gt;esp32.net&lt;/a&gt; und den Produkseiten von &lt;a href=&#34;http://espressif.com/en/products/hardware&#34;&gt;Espressif&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Günstige Bezugsquellen findet man bei EBai, Amazon und natürlich Ali-Express.&lt;/p&gt;

&lt;h1 id=&#34;vorbereitung&#34;&gt;Vorbereitung&lt;/h1&gt;

&lt;p&gt;Man braucht:
* Einen ESP-WROOM-32 oder ESP-32
* Einen USB-to-Serial Adapter
* Eine 3.3V Quelle (wird meistens bei den USB2Serial Adaptern angeboten)&lt;/p&gt;

&lt;p&gt;Die einfachste Verkabelung ist, wenn man die +3.3V vom USB2Serial-Adapter mit dem 3V3 und dem EN Pin auf dem ESP-Chip verbindet, sowie den Ground (GND) mit dem Ground GND.
Weiter muss man den TX vom USB2Serial-Adapter mit dem RX auf dem Chip und den RX vom Adapter mit dem TX vom Chip verbinden.
Um eine Firmware auf den Chip zu laden muss man den IO0-Port vom Chip an den Ground (GND) hängen. Der einfachheit halber kann man hier einen Schalter/Taster oder auch einfach ein trennbares Kabel verwenden.&lt;/p&gt;

&lt;p&gt;So ist der ESP-32 bereits einsatzbereit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------+      +---------------+
| USB2Serial |      |   ESP-x-32    |
|            |      |           3V3 |---+-- +3.3V
|         Tx +------+ Rx         EN |--/
|   GND   Rx +------+ Tx   GND  IO0 |
+----+-------+      +-------+----+--+
     |                      |    |
     +----------------------+----+
                                \ Nur beim Upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Achtung:&lt;/strong&gt; Auf keinen Fall mit +5.0V speisen, die ESP-32 Familie verträgt nur +1.8 - 3.8 Volt!&lt;/p&gt;

&lt;h1 id=&#34;benötigte-libraries-für-arduino&#34;&gt;Benötigte Libraries für Arduino&lt;/h1&gt;

&lt;p&gt;Um anständig mit dem ESP-32 zu arbeiten empfiehlt es sich mit dem &lt;a href=&#34;https://github.com/espressif/arduino-esp32&#34;&gt;Arduino-ESP32 Core&lt;/a&gt; zu arbeiten. Die Installation ist gut erklärt und spielt sich so ab:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Installation der &lt;a href=&#34;https://arduino.cc&#34;&gt;Arduino IDE&lt;/a&gt;, bei Slackware auch über SlackBuilds installierbar&lt;/li&gt;
&lt;li&gt;PySerial installieren, bei Slackware ist das bei &lt;a href=&#34;https://slackbuilds.org/repository/14.2/python/pyserial/&#34;&gt;SlackBuilds&lt;/a&gt; verfügbar
** Es kann auch mittels &lt;code&gt;pip install pyserial&lt;/code&gt; installiert werden&lt;/li&gt;
&lt;li&gt;Neue Hardware installieren: &lt;code&gt;mkdir -p ~/Arduino/hardware/espressif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Das Git-Projekt klonen: &lt;code&gt;git clone https://github.com/espressif/arduino-esp32.git ~/Arduino/hardware/espressif/esp32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Abhängigkeiten installieren: &lt;code&gt;cd ~/Arduino/hardware/espressif/esp32/tools &amp;amp;&amp;amp; python get.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;stack-trace&#34;&gt;Stack-Trace&lt;/h2&gt;

&lt;p&gt;Optional kann (empfohlen) der &lt;a href=&#34;https://github.com/me-no-dev/EspExceptionDecoder&#34;&gt;ESP ExceptionDecoder&lt;/a&gt; installiert werden um einen lesbaren Stacktrace zu erhalten beim debuggen.&lt;/p&gt;

&lt;h1 id=&#34;programm-hochladen&#34;&gt;Programm hochladen&lt;/h1&gt;

&lt;p&gt;Nach einem Neustart der Adruino IDE sind nun die benötigten Hardware Einträge vorhanden. Für einen ESP-WROOM-32 werden folgende Einstellungen benötigt:
* &lt;strong&gt;Board:&lt;/strong&gt; FireBeetle-ESP-32
* &lt;strong&gt;Flash Frequency:&lt;/strong&gt; 80MHz
* &lt;strong&gt;Upload Speed:&lt;/strong&gt; 921600
* &lt;strong&gt;Port:&lt;/strong&gt; /dev/ttyUSB0 oder /dev/ttyUSB1 - das kann sich ändern wenn man den Chip resettet&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//ranta.ch/images/tutorials/arduino_esp32/arduino_config.png&#34; title=&#34;Arduino-IDE Konfiguration&#34;&gt;&lt;img src=&#34;//ranta.ch/images/tutorials/arduino_esp32/arduino_config.png&#34; alt=&#34;Arduino-IDE Konfiguration&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Um nun das Programm hoch zu laden, muss der &lt;code&gt;IO0&lt;/code&gt; Pin auf LOW gesetzt werden, also mit dem Ground (GND) verbunden werden. Anschliessend Power-Off und Power-On um den Chip zu resetten. Wichtig ist, dass wenn man einen Taster verwendet um &lt;code&gt;IO0&lt;/code&gt; auf low zu halten, dieser muss die ganze Zeit gedrückt werden.&lt;/p&gt;

&lt;p&gt;Wenn der Chip resettet hat, muss nochmals der Port geprüft werden - dieser kann sich bei diesem Vorgang ändern (Warum auch immer das resetten eine Auswirkung auf meinen USB-to-Serial Adapter hat weiss ich nicht).&lt;/p&gt;

&lt;p&gt;Um das Programm hoch zu laden kann man nun einfach die in der IDE zur verwendung gestellte Funktion verwenden (Icons oben links zum kompilieren und hochladen).
Nach dem Hochladen sollte der Port &lt;code&gt;IO0&lt;/code&gt; wieder vom Ground getrennt werden und der Chip erneut resettet durch Power Off und Power On.&lt;/p&gt;

&lt;h2 id=&#34;einfaches-programm&#34;&gt;Einfaches Programm&lt;/h2&gt;

&lt;p&gt;Eines der einfachsten Programme kann so aussehen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(115200);
}
 
void loop() {
  Serial.println(&amp;quot;Hello from ESP-WROOM-32&amp;quot;);
  delay(500);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nach dem hochladen kann dann wie gewohnt über den Serial-Monitor in der Arduino-IDE die Meldung angeschaut werden.&lt;/p&gt;

&lt;h1 id=&#34;demos-und-mehr&#34;&gt;Demos und mehr&lt;/h1&gt;

&lt;p&gt;Espressif hat im &lt;a href=&#34;https://github.com/espressif/esp-idf&#34;&gt;ESP-IDF Github Repository&lt;/a&gt; Demos und Beispiele. Diese sind zwar für die esp-idf ausgelegt, zeigen aber wie Bluetooth und WiFi genutzt werden kann.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adruino programmieren mit KDevelope</title>
      <link>//ranta.ch/tutorials/Programming_Arduino_With_Kdevelop/</link>
      <pubDate>Sun, 05 Mar 2017 10:41:12 +0100</pubDate>
      
      <guid>//ranta.ch/tutorials/Programming_Arduino_With_Kdevelop/</guid>
      <description>

&lt;p&gt;Wie jeder Programmierer hat man seinen eigenen Favoriten was die Entwicklungsumgebung angeht. Das ist bei mir Slackware64-current mit KWrite und KDevelop, sowie Yakuake als Konsole - und definitiv nicht das grauslige Java-Arduino-Studio :)&lt;/p&gt;

&lt;p&gt;Einen Allgemeinen Artikel wie man das zusammenbringt findet man auf dem &lt;a href=&#34;http://playground.arduino.cc/Code/Kdevelop&#34;&gt;Arduino Playground&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;tl-dr&#34;&gt;TL;DR;&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;KDevelop installieren&lt;/li&gt;
&lt;li&gt;Die AVR-Toolchain installieren&lt;/li&gt;
&lt;li&gt;Die neuste &lt;code&gt;adruino.zip&lt;/code&gt; herunterladen: &lt;a href=&#34;http://forum.arduino.cc/index.php?topic=244741.0&#34;&gt;New Template for Kdevelop/CMake for Arduino 1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Entpacken und als tar.bz2 neu verpacken: &lt;code&gt;unzip arduino.zip &amp;amp;&amp;amp; cd arduino &amp;amp;&amp;amp; tar -cjf ../arduino.tar.bz2 .&lt;/code&gt;
3.1 Für alle nach &lt;code&gt;/usr/share/[kde4/]apps/kdevappwizard/templates/&lt;/code&gt; kopieren
3.2 Oder als Egomane nach &lt;code&gt;~/.kde/share/apps/kdevappwizard/templates/&lt;/code&gt; kopieren&lt;/li&gt;
&lt;li&gt;Have fun&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;im-detail&#34;&gt;Im Detail&lt;/h1&gt;

&lt;h2 id=&#34;die-komplette-avr-toolchain-installieren&#34;&gt;Die komplette AVR-Toolchain installieren&lt;/h2&gt;

&lt;p&gt;Bei Slackware geht das am einfachsten über &lt;a href=&#34;https://slackbuilds.org/&#34;&gt;SlackBuilds.org&lt;/a&gt;, andere Distributionen haben das schon im Package-Manager enthalten.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;avr-binutils&lt;/code&gt; Benötigte Tools für das Cross-Compiling&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avr-gcc&lt;/code&gt; Cross-Compiling für AVR&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avr-gdb&lt;/code&gt; für das debuggen mittels GDB&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avr-libc&lt;/code&gt; beinhaltet die C-Library&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avrdude&lt;/code&gt; für den Up-/Download der Firmware&lt;/li&gt;
&lt;li&gt;Optional &lt;code&gt;avarice&lt;/code&gt; wenn man mittels JTag debuggen will&lt;/li&gt;
&lt;li&gt;Optional &lt;code&gt;avra&lt;/code&gt; für Atmel Assembler&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kdevelop-templates&#34;&gt;KDevelop Templates&lt;/h2&gt;

&lt;p&gt;Zuerst braucht man das neuste &lt;code&gt;arduino.zip&lt;/code&gt; aus dem Thread &lt;a href=&#34;http://forum.arduino.cc/index.php?topic=244741.0&#34;&gt;New Template for Kdevelop/CMake for Arduino 1.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dieses zip muss man neu packen als &lt;code&gt;tar.bz2&lt;/code&gt;, also entpacken und neu verpacken: &lt;code&gt;unzip arduino.zip &amp;amp;&amp;amp; cd arduino &amp;amp;&amp;amp; tar -cjf ../arduino.tar.bz2 .&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Will man das Template für alle Benutzer zur Verfügung stellen, dann muss man es nach &lt;code&gt;/usr/share/[kde4/]apps/kdevappwizard/templates/&lt;/code&gt; kopieren.
Will man das Template nur für sich, dann kann man es nach &lt;code&gt;~/.kde/share/apps/kdevappwizard/templates/&lt;/code&gt; kopieren.&lt;/p&gt;

&lt;h2 id=&#34;neues-projekt&#34;&gt;Neues Projekt&lt;/h2&gt;

&lt;p&gt;Startet man KDevelop und erstellt ein neues Projekt, hat man unter dem Punkt &lt;strong&gt;C/C++&lt;/strong&gt; nun das Template &lt;strong&gt;Arduino&lt;/strong&gt; welches man verwenden kann.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//ranta.ch/images/tutorials/kdevelope_arduino_new_project.png&#34; alt=&#34;KDevelop New Project Wizard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nachdem das Projekt erstellt wurde, hat man ein neues Demo-File und ein paar Libraries welche man gut gebrauchen kann.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//ranta.ch/images/tutorials/kdevelope_arduino_new_project_files.png&#34; alt=&#34;KDevelop Project Structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Damit die includes gefunden werden, muss noch der avr-include Path konfiguriert werden. Das macht man am einfachsten über die Project-Settings, wo man den Pfad &lt;code&gt;/usr/avr/include/&lt;/code&gt; hinzufügt:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//ranta.ch/images/tutorials/kdevelope_arduino_new_project_settings.png&#34; alt=&#34;KDevelop Project Structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Was man nun noch anpassen muss ist die &lt;code&gt;CMakeLists.txt&lt;/code&gt; mit einer eigenen Konfig unter dem &lt;code&gt;platform&lt;/code&gt; Ordner (analog zu dem schon bestehenden &lt;code&gt;arduino_leonardo&lt;/code&gt;) oder man importiert die &lt;code&gt;libarduino.cmake&lt;/code&gt; und definiert seine eigenen Parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set(ARDUINO_BOARD &amp;quot;AVR_LEONARDO&amp;quot;)
set(ARDUINO_VARIANTS &amp;quot;leonardo&amp;quot;)
set(ARDUINO_MCU &amp;quot;atmega32u4&amp;quot;)
set(ARDUINO_FCPU &amp;quot;16000000L&amp;quot;)
set(ARDUINO_UPLOAD_PROTOCOL &amp;quot;avr109&amp;quot;)
set(ARDUINO_UPLOAD_SPEED &amp;quot;57600&amp;quot;)
set(ARDUINO_PORT &amp;quot;/dev/ttyACM0&amp;quot;)

include(${CMAKE_SOURCE_DIR}/platforms/libarduino.cmake)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;template-anpassen&#34;&gt;Template anpassen&lt;/h3&gt;

&lt;p&gt;Das aktuelle Template hat immer den &lt;em&gt;Arduino Leonardo&lt;/em&gt; als Standard drin. Wenn man das nicht will, resp. mit einem &lt;em&gt;Arduino Nano&lt;/em&gt; oder anderen Board arbeitet, kann man das Template auch entsprechend anpassen. Also entpacken, Anpassen und neu verpacken (wie oben erleutert).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>